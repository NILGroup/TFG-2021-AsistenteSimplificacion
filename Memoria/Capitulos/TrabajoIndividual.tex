\chapter{Trabajo individual}
\label{cap:trabajoIndividual}

\section{Estefanía Ortega Ávila}

En primer lugar, mi labor en este TFG se centró en una investigación de las tareas y los pasos a seguir que se llevan a cabo para adaptar un texto a Lectura Fácil. Para ello, consulté diversas webs y vídeos que me proporcionaran dicha información. De esta manera, entendí a qué público iba dirigida este tipo de lectura y qué técnicas eran las más utilizadas. 

Posteriormente, tanto mi compañero como yo, identificamos diferentes herramientas que podrían ser útiles para transformar textos, probando algunas de ellas, haciéndonos una idea de qué medios disponen los editores para realizar su labor.

Una vez realizada la investigación, mi compañero y yo comenzamos a estudiar las tecnologías que iban a hacer posible la implementación de nuestro asistente web. Optamos por hacer uso de servicios API REST, así como de la librería spaCy para el PLN.

Por otro lado, y esta es la que yo abordé, tenemos la implementación de la aplicación, es decir, la interfaz visual con el que el usuario editor interactuará y hará uso de las diferentes funcionalidades. 

Para el desarrollo de esta implementación, utilicé JavaScript para que los resultados de la llamada al servidor mediante una promesa Fetch a un endpoint me devolviera un objeto JSON que, al operar sobre él, plasme cierta información en la interfaz; usando HTML, para el desarrollo de la interfaz visual, y CSS para dar estilo a ésta (fuentes, tamaños, colores…).


La parte donde tuve más dificultad fue la de dibujar el árbol de dependencias con el aspecto de árbol genealógico y el poder procesar el objeto JSON que recibo del servidor para representar cada nodo con sus correspondientes dependencias. La solución por la que opté fue la de implementar un algoritmo BFS para poder recorrer el objeto, obteniendo la estructura de árbol deseada.

Otra parte de especial dificultad fue la relacionada con la funcionalidad ``Intercambiar'' en el caso de que se tuviera que modificar dos palabras independientes entre sí y, a su vez, las dependientes de éstas, reflejándose estos cambios en el borrador del texto final. Para solventarlo, hice uso de arrays auxiliares que me permitieron obtener el resultado que quería en el borrador para poder cambiar el texto dinámicamente.

Realicé algunas pruebas en Postman de los diferentes servicios de NIL-WS-API para validar que el comportamiento de la interfaz, se correspondía con lo que la API devolvía en su respuesta, por ejemplo, en el caso de comprobar que si una palabra se muestra de color rojo en el árbol, la API nos indique que dicha palabra es compleja. Esto me permitió, por primera vez, hacer uso de la herramienta Postman, la cual es bastante apropiada para el testeo de APIs.

Para el diseño de la interfaz del asistente, tomé en cuenta las recomendaciones de mis tutoras en las reuniones periódicas, sobre todo en lo que concierne a nombres de botones, elementos de la interfaz visibles o no visibles al pinchar en una determinada funcionalidad, etc.



Además de la implementación, me encargué de algunas de las partes que consta la memoria. En el capítulo 1, redacté los puntos relacionados con la motivación y los objetivos que persigue este asistente. El capítulo 2, los puntos 2.3 y 2.4 relacionados con proyectos, programas y aplicaciones en LF. Con respecto al capítulo 4, fui la persona encargada de desarrollarlo en su totalidad hablando sobre la aplicación y sus diferentes funcionalidades y vistas, mientras que del capítulo 5 fui la autora del punto 5.1 y 5.3, relacionados con la arquitectura y con la implementación del asistente, respectivamente. Finalmente, el capítulo 6, lo elaboré junto con la ayuda de mi compañero. Por último, traduje al inglés la parte de mi trabajo individual.



Por supuesto, se fue realizando modificaciones en aquellas partes que a nuestras tutoras les parecía que debíamos mejorar.

\section{Javier Sesé García}

Mi contribución al proyecto comenzó investigando a quién iba dirigida la Lectura Fácil y las formas que se utilizaban para adaptar textos. 

Posteriormente, nos centramos en el diseño de la arquitectura de la aplicación, la cual es una arquitectura REST basada en endpoints. Elegimos este diseño ya que nos pareció que es fácilmente ampliable en el caso de que se quisiera realizar un servicio nuevo.

Implementé esta arquitectura con Flask, del cual he adquirido los conocimientos para ser capaz de desplegar el servidor en él. He elegido Flask ya que, aunque tenía más experiencia con Django, me ha parecido un entorno ligero y fácil de usar y una oportunidad de ampliar mis conocimientos.

En lo que concierne a las herramientas, investigué y aprendí a usar la librería spaCy que otorga la principal funcionalidad de análisis gramatical del asistente. Para ello tuve que familiarizarme con todas las funcionalidades de spaCy que hemos usado, investigando en profundidad lo que podían hacer y de qué manera, así como hacer un repaso de la gramática, para entender completamente el funcionamiento y uso que le podemos dar a la funcionalidad del etiquetado gramatical de spaCy.


Además, implementé las llamadas a los diferentes servicios de NIL-WS-API desde la parte del servidor, escrito con lenguaje Python.

Al igual que mi compañera, me serví de Postman para verificar los datos que recibía el servidor, y gracias a ello encontré una carencia de la API, y es que no acepta caracteres especiales, ya que estos se pasan como argumento de la URI, por lo que decidí, como posible solución, eliminar estos caracteres de las palabras.

 Por el contrario, esta solución presentaba otro problema en sí, y es que sin esos caracteres especiales se da ambigüedad en los resultados de los servicios, como por ejemplo el de sinónimos, que la propia API ya considera retornando todos los posibles valores, por lo que decidimos hacer lo mismo y dejar a elección del usuario el valor con el que quedarse.

Desconocía como se debían de hacer las llamadas a los endpoints del servidor, lo que me supuso un esfuerzo hasta que aprendí a realizar las promesas mediante la operación Fetch. Adicionalmente, implementé parte de la funcionalidad de las propias promesas en JavaScript junto con mi compañera.

También investigué como hacer la conjugación de palabras a partir de su lema, tiempo verbal y número gramatical, lo que me llevó a la conclusión de que no sería capaz de hacerlo solamente con spaCy, por lo que busqué otras formas de realizarlo en Python. 

Llegué a dar con varias formas de realizar esta conjugación, pero ninguna adaptada al texto en castellano a pesar de que encontré una posibilidad de montar otro servidor en Java para ello, pero valoré que no tenía el tiempo suficiente para aprender a usarlo lo cual no nos servia para esta aplicación ya que estaba disponible en inglés. 

Por otro lado, estudié la opción de hacer nuestro propio conjugador, pero de nuevo valoré que no teníamos el tiempo necesario suficiente para ello. Por todo ello, decidimos dejar la posibilidad de la conjugación automática de palabras como posible trabajo futuro. 


Una vez terminada la implementación me encargué de alojar el servidor en el contenedor que nos han otorgado (\url{https://holstein.fdi.ucm.es/tfg/2021/simpli/}). Para ello, tuve que aprender cómo usarlo, así como de saber lanzar el servidor de Flask en un docker, lo que ha obligado a realizar una modificación en las rutas de los archivos .js y .css locales.

En cuanto a la memoria además del resumen, redacté, en lo que concierne al capítulo 1, la sección de ``Estructura del documento''. En el capítulo 2  me encargué de los puntos 2.1 y 2.2. El capítulo 3 relacionados con las herramientas lo elaboré al completo. El capítulo 5 escribí las tres primeras secciones ligadas a la parte del servidor de la aplicación y la librería spaCy, salvo el punto 5.1.1. Junto con la ayuda de mi compañera, redactamos el capítulo 6 para explicar las conclusiones y posibles mejoras. Finalmente traduje la parte del resumen y palabras claves al inglés, así como mi trabajo individual.



